<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Huiyin(Cloris) He" />


<title>Clustering Analysis</title>

<script src="site_libs/header-attrs-2.7/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-sm-12 col-md-4 col-lg-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-sm-12 col-md-8 col-lg-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Clustering Analysis</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="index.html">Analysis</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Clustering Analysis</h1>
<h4 class="author">Huiyin(Cloris) He</h4>
<h4 class="date">8/25/2020</h4>

</div>


<div id="part-1.-data-cleaning-and-visualization" class="section level1">
<h1><strong>Part 1. Data Cleaning and Visualization</strong></h1>
<pre class="r"><code>##check rows and columns in data
dim(data1)</code></pre>
<pre><code>## [1] 1741041       9</code></pre>
<pre class="r"><code>str(data1)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1741041 obs. of  9 variables:
##  $ cust_id            : int  67 67 67 67 67 67 67 67 67 67 ...
##  $ yearmonth          : int  201012 201101 201102 201103 201104 201105 201106 201107 201108 201109 ...
##  $ survey_date        : Factor w/ 2619 levels &quot;&quot;,&quot;01/01/2014&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ months_since_survey: int  -64 -63 -62 -61 -60 -59 -58 -57 -56 -55 ...
##  $ satis_survey       : int  NA NA NA NA NA NA NA NA NA NA ...
##  $ cust_age           : num  31.8 31.9 32 32.1 32.1 ...
##  $ cust_tenure        : num  0.118 0.203 0.279 0.364 0.446 ...
##  $ total_investments  : int  14 14 14 14 14 14 14 14 14 14 ...
##  $ tottrans           : int  0 0 0 0 4 0 28 45 84 76 ...</code></pre>
<div id="a.-frequency-counts-of-surveys-and-by-month" class="section level2">
<h2>A. Frequency counts of surveys and by month</h2>
<p>Before doing any data cleaning, we report how many customers answered a 1,2,3,4,5 on the satis_survey variable.</p>
<pre class="r"><code>##PART A.
library(dplyr)
library(lubridate)
library(tidyr) 
library(ggplot2)
library(data.table) 
library(sqldf)
library(cluster)
library(NbClust)
library(factoextra)
  #counts 
count_survey&lt;-as.data.frame(table(data1$satis_survey))

  #counts and percentages
total_survey&lt;-sum(!is.na(data1$satis_survey))
count_survey$percentage&lt;-with(count_survey,Freq/total_survey*100)
colnames(count_survey)&lt;-c(&#39;Ratings&#39;,&#39;Counts&#39;,&#39;Percentages&#39;)
count_survey</code></pre>
<pre><code>##   Ratings Counts Percentages
## 1       1   5061    17.02493
## 2       2   5144    17.30413
## 3       3   5494    18.48152
## 4       4   6403    21.53934
## 5       5   7625    25.65008</code></pre>
<p>We also found out how many surveys were conducted by month for the entire sample.</p>
<pre class="r"><code>  #convert factor to date
data1$survey_date_convert&lt;-mdy(data1$survey_date)
  #Extract month
data1$survey_month&lt;-month(mdy(data1$survey_date))
  
  #counts by month
count_survey_by_month&lt;-as.data.frame(table(data1$survey_month))
mymonth&lt;-c(&#39;January&#39;,&#39;February&#39;,&#39;March&#39;,&#39;April&#39;,&#39;May&#39;,&#39;June&#39;,&#39;July&#39;,&#39;August&#39;,&#39;September&#39;,&#39;October&#39;,&#39;November&#39;,&#39;December&#39;)
colnames(count_survey_by_month)&lt;-c(&#39;Month&#39;,&#39;Counts of survey&#39;)
count_survey_by_month$Month&lt;-mymonth[count_survey_by_month$Month]
count_survey_by_month</code></pre>
<pre><code>##        Month Counts of survey
## 1    January             2425
## 2   February             2532
## 3      March             2402
## 4      April             2396
## 5        May             2353
## 6       June             2450
## 7       July             2473
## 8     August             2542
## 9  September             2532
## 10   October             2748
## 11  November             2439
## 12  December             2435</code></pre>
<p>The survey shows that around 26% of surveyed customers giving rating of 5 and 17% giving rating of 1. We can’t say the firm has a high customers satisfaction level because only 1⁄4 of the customers are fully satisfied with the firm and less than 50% of customers feel “very satisfied” or “satisfied”.</p>
</div>
<div id="b.-remove-customers-with-impossible-values" class="section level2">
<h2>B. Remove customers with impossible values</h2>
<ul>
<li><p>Negative or missing values for total_investments (dollars can’t be negative, or missing)</p></li>
<li><p>Zero, negative or missing values for either cust_age, cust_tenure, or tottrans</p></li>
</ul>
<pre class="r"><code>  #remove customers
subset1&lt;-data1[is.na(data_org$total_investments) |
                 data_org$total_investments&lt; 0 |
                 is.na(data_org$cust_age) |
                 is.na(data_org$cust_tenure) |
                 is.na(data_org$tottrans) |
                 data_org$cust_ag &lt;=0 |
                 data_org$cust_tenur &lt;=0 |
                 data_org$tottrans &lt;=0 ,&#39;cust_id&#39;]
  
  # number of removed customers
length(unique(subset1))             </code></pre>
<pre><code>## [1] 17227</code></pre>
<p>Removed customers: 17,227</p>
<pre class="r"><code>  # the cleaned data
data2&lt;-data_org[!(data_org$cust_id %in% unique(subset1)),]
  # number of remaining rows
dim(data2)</code></pre>
<pre><code>## [1] 413436      9</code></pre>
<pre class="r"><code>  # number of removed rows
diff(dim(data2)-dim(data_org))</code></pre>
<pre><code>## [1] 1327605</code></pre>
<pre class="r"><code>  #remaining customers
length(unique(data2$cust_id))</code></pre>
<pre><code>## [1] 7773</code></pre>
<p>Remaining customers: 7,773</p>
<p>There is too much impossible data in this dataset which is uncommon. Out of 25000 customers, we removed more than half of them and only 7,773 remains which is way less data than the original ones. More than half of the rows were removed from the dataset, leaving only around 23% of the original data. So there might be a problem on the firm’s data.</p>
</div>
<div id="c.-remove-outlier-customers" class="section level2">
<h2>C. Remove outlier customers</h2>
<p>In order to ensure that the analysis is not heavily influenced by any outlier customers with extreme values, we will remove any customers in the remaining dataset who have data values in the top 1% for either monthly investments or monthly transactions. These customers may not be representative of the overall customer base and should be removed in their entirety.</p>
<pre class="r"><code>##PART C.
  # top 1%  total investment and tottrans 
top1_inv&lt;-quantile(data2$total_investments, probs=0.99, names=FALSE) 
top1_inv</code></pre>
<pre><code>## [1] 424080</code></pre>
<pre class="r"><code>top1_trans&lt;- quantile(data2$tottrans, probs=0.99, names=FALSE) 
top1_trans</code></pre>
<pre><code>## [1] 201</code></pre>
<pre class="r"><code>  # remove outliers
subset2&lt;-data2[data2$total_investments&gt;= top1_inv|
                       data2$tottrans&gt;= top1_trans,&#39;cust_id&#39;]

  # number of additional removed customers
length(unique(subset2))</code></pre>
<pre><code>## [1] 745</code></pre>
<p>Removed customers: 745</p>
<pre class="r"><code>  # cleaned data
data3&lt;-data2[!(data2$cust_id %in% unique(subset2)),]
  # remaining rows
dim(data3)</code></pre>
<pre><code>## [1] 368868      9</code></pre>
<pre class="r"><code> # number of romoved rows
dim(data2)-dim(data3)</code></pre>
<pre><code>## [1] 44568     0</code></pre>
<pre class="r"><code># remaining customers
length(unique(data3$cust_id))</code></pre>
<pre><code>## [1] 7028</code></pre>
<p>Remaining customers: 7,028</p>
</div>
<div id="d.-data-visualization" class="section level2">
<h2>D. Data Visualization</h2>
<pre class="r"><code>##PART D.
  # remove na in the satis_survey
data4&lt;-data3[!is.na(data3$satis_survey),]

# chart 1
data5&lt;-data4[,c(&quot;cust_age&quot;,&quot;total_investments&quot;,&quot;satis_survey&quot;)] 
data5$Age&lt;-cut(data5$cust_age,c(-Inf,30,45,60,Inf),
               labels=c(&#39;17-30&#39;,&#39;31-45&#39;,&#39;46-60&#39;,&#39;60+&#39;)) 

ggplot(data5,aes(x=satis_survey,y=total_investments,fill=Age)) + 
  geom_col()  +
  scale_y_continuous(
    labels = scales::number_format(accuracy = 0.1,
                                   decimal.mark = &#39;,&#39;)) +
  ggtitle(&quot;Relationship between satis_survey and total_ investments&quot;)+ 
  xlab(&quot;Customer Satisfaction Ratings&quot;) + ylab(&quot;Total Investments&quot;)  </code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>The graph shows that customers who give a rating of 5 make more investments to the company, compared to the rest of rating groups. With higher customer satisfaction levels, customers tend to invest more to the company and therefore, if the company wants to attract more investments, they need to maintain a high customer satisfaction level.</p>
<p>Additionally, the age group 17-30 and above 60 give higher rating of 4 or 5 which generates higher investments. Therefore, we recommend that the company should target mainly people in age groups of 60+ and 17-30 when putting out advertisements so that they could increase the chance to attract more investments.</p>
<pre class="r"><code># chart 2 - lollipop plot 
data4%&gt;% 
  tail(350) %&gt;% 
  ggplot( aes(x=cust_tenure, y= tottrans )) + 
  geom_line() + 
  geom_point() +
  ggtitle(&quot;Relationship between customer tenure and total transactions&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<pre class="r"><code>#chart 3 - density
data4 %&gt;% 
  filter( cust_tenure&lt;12 ) %&gt;% 
  ggplot( aes(x=cust_tenure)) + 
  geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8)+
  ggtitle(&quot;The density distribution of customer tenure&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-11-2.png" width="672" /></p>
<p>We can see the density of customer tenure substantially reduces as the number of customer tenure increases which indicates that people are generally not having a relationship with the company for too long. Most of customers tend to stay with the company for 1 to 5 years, approximately.</p>
</div>
</div>
<div id="part-2.-more-cleaning-and-analytics" class="section level1">
<h1><strong>Part 2. More cleaning and Analytics</strong></h1>
<p>We will continue doing analysis based on the remaining 7,028 customers from Part 1.</p>
<div id="e.-drop-customers-who-have-noncontiguous-data" class="section level2">
<h2>E. Drop customers who have noncontiguous data</h2>
<p>There’s another issue to address in the data: The firm has reported data tracking issues because sometimes entire rows of data are missing for some customers. Customers should have record for every month since they became customers of the firm but some customers are missing data for one or more months. And we need to remove all of these customers who are missing one or more data rows over time.</p>
<pre class="r"><code>##PART E.
time.diff=c(diff(data$months_since_survey),order_by = data$cust_id)

  #customers w/ date issue
bad.cust=sort(unique(data$cust_id[time.diff&gt;1]))
length(unique(bad.cust))</code></pre>
<pre><code>## [1] 4219</code></pre>
<p>We found out there are 4,219 customers with date issue.</p>
<pre class="r"><code>  #rows removed
removed=data$cust_id %in% unique(bad.cust)

  #new data
data2=data[!(data$cust_id %in% unique(bad.cust)),]

  #remaining rows
dim(data2)</code></pre>
<pre><code>## [1] 117140      9</code></pre>
<pre class="r"><code>  #remaining customers
length(unique(data2$cust_id))</code></pre>
<pre><code>## [1] 2809</code></pre>
<p>After we removed the customers with date issue, we had 2,809 remaining customers.</p>
</div>
<div id="f.-remove-customers-who-were-surveyed-more-than-1-time-or-not-at-all" class="section level2">
<h2>F. Remove customers who were surveyed more than 1 time, or not at all</h2>
<p>Another important issue to address with the firm’s surveys is that customers are only supposed to be surveyed one time. However, some customers might have been surveyed more than once or not at all. We should only retain customers who were surveyed exactly once during the study period, and remove all other customers, including any customers surveyed two or more times, or not surveyed at all.</p>
<pre class="r"><code>##PART F. 
  #convert factor to date
data2$surveydates.convert &lt;- as.Date(data2$survey_date, format=&quot;%m/%d/%y&quot;)

  #create frequency table 
subset1=data2[,c(&#39;cust_id&#39;,&#39;surveydates.convert&#39;)]
subset2=subset1[!(is.na(subset1$surveydates.convert)),]
freq.count=as.data.frame(table(subset2$cust_id))
colnames(freq.count)&lt;-c(&#39;cust_id&#39;,&#39;freq&#39;)

  #valid customers that have 1 survey
sum(freq.count$freq==1)</code></pre>
<pre><code>## [1] 2476</code></pre>
<pre class="r"><code>  #invalid customers that have more than 1 survey
length(unique(freq.count$cust_id))-sum(freq.count$freq==1)</code></pre>
<pre><code>## [1] 326</code></pre>
<pre class="r"><code> #maximum times surveyed 
max(freq.count$freq)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>  #number of customers w/ maximum number of survey
sum(freq.count$freq==max(freq.count$freq))</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>  #new data
freq.count.clean=freq.count[freq.count$freq==1,]
data3=data2[data2$cust_id%in%unique(freq.count.clean$cust_id),]
  
  #remaining customers 
length(unique(data3$cust_id))</code></pre>
<pre><code>## [1] 2476</code></pre>
<pre class="r"><code>  #remaining rows:
dim(data3)</code></pre>
<pre><code>## [1] 100046     10</code></pre>
<p>We found out there are 2,476 valid Customers with 1 survey and 326 invalid customers. Out of those invalid customers, 1 customer was surveyed 6 times.</p>
</div>
<div id="g.-the-influence-of-customer-satisfaction-levels-on-investment" class="section level2">
<h2>G. The influence of customer satisfaction levels on investment</h2>
<p>After data cleaning, we want to understand how customer satisfaction levels influence how much money customers invest or remove from the firm and we will compare 1 month before being surveyed to 3 months after being surveyed.</p>
<div id="step-1" class="section level3">
<h3>step 1</h3>
<p>Every customer we analyze must be present for at least 1 month before they were surveyed (every customer surveyed must have a months_since_survey = -1.) If there are any customers who do not have data 1 month before being surveyed, we should exclude these customers because we cannot observe their investment balances prior to them being surveyed.</p>
<pre class="r"><code>##PART G.
##a.
  #customers who have data 1 month before survey
condition1=data3$months_since_survey==-1
good.cust=sort(unique(data3$cust_id[condition1==TRUE]))
  
  #remaining customers
length(unique(good.cust))</code></pre>
<pre><code>## [1] 2158</code></pre>
<pre class="r"><code>  #removed customers
length(unique(data3$cust_id))-length(unique(good.cust))</code></pre>
<pre><code>## [1] 318</code></pre>
<pre class="r"><code>  #new data
data4=data3[c(&#39;cust_id&#39;,&#39;months_since_survey&#39;,&#39;total_investments&#39;)]
data4=subset(data4,months_since_survey==-1)
data4=data4[c(&#39;cust_id&#39;,&#39;total_investments&#39;)]
  #change column names
colnames(data4)&lt;-c(&#39;cust_id&#39;,&#39;Inv_1M_Bef&#39;)</code></pre>
<p>There are 318 customers who do not have data 1 month before being surveyed and we need to remove them. We have remaing 2,158 customers who have observed data one month before their survey (months_since_survey = -1).</p>
</div>
<div id="step-2" class="section level3">
<h3>step 2</h3>
<p>We also found out there are some customers leave before months_since_survey = 3 (3 months after being surveyed). For any customers whose follow up times are less than 3 months (the maximum observable months_since_survey &lt; 3), we need to set the INV_3M_Aft = 0. It’s because if the customer is no longer with the firm, by definition they should have closed all of their accounts and therefore, they won’t have any money with the firm (balance = $0.00).</p>
<pre class="r"><code>##b.
  #largest &#39;months_since_survey&#39; by cust_id
sub1=sqldf(&#39;SELECT  cust_id, max(months_since_survey),total_investments
      FROM data3 
      group by cust_id&#39;)

  #extract customers w/ months_since_survey&gt;=3
sub2=sub1$cust_id[sub1$`max(months_since_survey)`&gt;=3]
length(unique(sub2))</code></pre>
<pre><code>## [1] 2369</code></pre>
<pre class="r"><code>  #extract customers w/ months_since_survey==3
data5=sqldf(&#39;SELECT  cust_id, total_investments
      FROM data3 
      WHERE months_since_survey ==3&#39;)
colnames(data5)&lt;-c(&#39;cust_id&#39;,&#39;INV_3M_Aft&#39;)

  #extract customers w/ months_since_survey&lt;3
sub3=sub1$cust_id[sub1$`max(months_since_survey)`&lt;3]
data6=data3[data3$cust_id%in%sub3,]
data6=sqldf(&#39;SELECT  cust_id,total_investments==0
      FROM data6 
      group by cust_id&#39;)
colnames(data6)&lt;-c(&#39;cust_id&#39;,&#39;INV_3M_Aft&#39;)
  
  #customers who were left before months=3
length(data6$cust_id)</code></pre>
<pre><code>## [1] 107</code></pre>
<pre class="r"><code>  #join two tables
data.b=rbind(data5,data6)</code></pre>
<p>There are 2,369 customers with months_since_survey &gt;= 3 and 107 customers with months_since_survey &lt; 3 whose INV_3M_Aft should be set to 0.</p>
</div>
<div id="step-3" class="section level3">
<h3>step 3</h3>
<p>Extract the cust_id and satis_survey for each customer where months_since_survey = 0.</p>
<pre class="r"><code>##c.
  #extract customers w/ months_since_survey==0
data7=sqldf(&#39;SELECT  cust_id,satis_survey
      FROM data3 
      WHERE months_since_survey==0&#39;)
  
  #frequency table
mytable=as.data.frame(table(data7$satis_survey))
colnames(mytable)&lt;-c(&#39;rating&#39;,&#39;counts&#39;)
mytable</code></pre>
<pre><code>##   rating counts
## 1      1    507
## 2      2    458
## 3      3    463
## 4      4    504
## 5      5    540</code></pre>
</div>
<div id="step-4" class="section level3">
<h3>step 4</h3>
<p>Create the summary dataset to see the effect and calculate the change in investments as: Inv_Chg = Inv_3M_Aft – Inv_1M_Bef.</p>
<pre class="r"><code>##d.
  #join tables
data.ready=merge(data7,data4,by=&#39;cust_id&#39;)
data.ready=merge(data.ready,data.b,by=&#39;cust_id&#39;)
data.ready$Inv_change=with(data.ready,INV_3M_Aft-Inv_1M_Bef)
head(data.ready)</code></pre>
<pre><code>##   cust_id satis_survey Inv_1M_Bef INV_3M_Aft Inv_change
## 1    1083            4      19653      20872       1219
## 2    1543            1      15677      14423      -1254
## 3    2243            4       3174       1045      -2129
## 4    2911            3      56633      63022       6389
## 5    4199            5       3658       2561      -1097
## 6    4446            4       1528        307      -1221</code></pre>
<pre class="r"><code>  #remaining customers
length(data.ready$cust_id)</code></pre>
<pre><code>## [1] 2158</code></pre>
<pre class="r"><code>  #avg survey answer of 1 or 2
avg.inv.1=mean(data.ready[data.ready$satis_survey==1 | data.ready$satis_survey==2,&#39;Inv_change&#39;])
round(avg.inv.1,2) </code></pre>
<pre><code>## [1] -627.15</code></pre>
<pre class="r"><code>  #avg survey answer of 4 or 5
avg.inv.2=mean(data.ready[data.ready$satis_survey==4 | data.ready$satis_survey==5,&#39;Inv_change&#39;])
round(avg.inv.2,2)</code></pre>
<pre><code>## [1] 877.54</code></pre>
<pre class="r"><code>  #difference between avg
round(avg.inv.2,2)-round(avg.inv.1,2) </code></pre>
<pre><code>## [1] 1504.69</code></pre>
<pre class="r"><code>  #money losing per customers:survey=1 or 2
avg.loss.1=mean(data.ready[data.ready$Inv_change&lt;0 &amp;
                             (data.ready$satis_survey==1 | data.ready$satis_survey==2),&#39;Inv_change&#39;])
round(avg.loss.1,2)</code></pre>
<pre><code>## [1] -10202.56</code></pre>
<pre class="r"><code>  #money losing per customers:survey=4 or 5
avg.loss.2=mean(data.ready[data.ready$Inv_change&lt;0 &amp;
                             (data.ready$satis_survey==4 | data.ready$satis_survey==5),&#39;Inv_change&#39;])
round(avg.loss.2,2)</code></pre>
<pre><code>## [1] -8912.4</code></pre>
<pre class="r"><code>  #Difference of avg. money loss
round(avg.loss.2-avg.loss.1,2)</code></pre>
<pre><code>## [1] 1290.16</code></pre>
<p>The average investment change for each customer with bad reviews (1 or 2) is -627.15. While the average investment change for customers with good review (4 or 5) is 877.54. It makes quite a big difference of $1,504.69 when a customer has a bad service experience versus a good service experience. Thus, we can see how the customer satisfaction level truly makes a significant impact on the investment the customers make. The better the service (higher rating), the more money customers would invest.</p>
<p>If we look at the average money the firm is losing from bad reviews (-10,202) vs. good reviews (-8,912.4), we can conclude that customers who had negative service encounters took out more money than customers who had positive service encounters. Additionally, both group are showing a high negative number, so when the customers decrease their investments, on average they will be pulling out a big amount of money. Not only the bad reviewers generate a bigger negative investment change, but also the customers who are giving good reviews also pulling out money from the company.</p>
</div>
</div>
</div>
<div id="part-3.-cluster-analysis" class="section level1">
<h1><strong>Part 3. Cluster Analysis</strong></h1>
<p>For this part, we want to see if different segments of customers responded differently to bad vs. good service.</p>
<p>We want to find out if there are certain customer segments who are at higher risk of taking out more money. So, we will perform a cluster analysis on the data, and calculate the average changes in dollars within each segment to see if there are certain groups of customers the firm needs to make sure always have good service encounters.</p>
<div id="a.-standardize-data" class="section level2">
<h2>A. Standardize Data</h2>
<pre class="r"><code>##PART A.
  #standardize data
X.scaled = as.matrix(scale(data[,c(&#39;Inv_1M_Bef&#39;,&#39;cust_age&#39;,&#39;cust_tenure&#39;,&#39;tottrans&#39;)]))

  #check mean &amp; sd
round(apply(X.scaled,2,mean),6)</code></pre>
<pre><code>##  Inv_1M_Bef    cust_age cust_tenure    tottrans 
##           0           0           0           0</code></pre>
<pre class="r"><code>apply(X.scaled,2,sd)</code></pre>
<pre><code>##  Inv_1M_Bef    cust_age cust_tenure    tottrans 
##           1           1           1           1</code></pre>
</div>
<div id="b.-elbow-plot" class="section level2">
<h2>B. Elbow Plot</h2>
<pre class="r"><code>##PART B.
  #Elbow method
fviz_nbclust(X.scaled,kmeans, nstart=1000, method=&quot;wss&quot;, k.max = 20,iter=1000) + 
  labs(title=&quot;Optimal Number of Clusters: Elbow Plot&quot;) + coord_cartesian(ylim=c(0,8000)) + geom_line(size=2)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>K=5 is our optimal number of clusters.</p>
</div>
<div id="c.-nbclust-approach-to-number-of-clusters" class="section level2">
<h2>C. NbClust approach to number of clusters</h2>
<pre class="r"><code>##PART C. 
  #nbclust method
nb=NbClust(X.scaled,distance=&quot;euclidean&quot;, min.nc=2, max.nc=20, method=&quot;kmeans&quot;)</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<pre><code>## *** : The Hubert index is a graphical method of determining the number of clusters.
##                 In the plot of Hubert index, we seek a significant knee that corresponds to a 
##                 significant increase of the value of the measure i.e the significant peak in Hubert
##                 index second differences plot. 
## </code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-23-2.png" width="672" /></p>
<pre><code>## *** : The D index is a graphical method of determining the number of clusters. 
##                 In the plot of D index, we seek a significant knee (the significant peak in Dindex
##                 second differences plot) that corresponds to a significant increase of the value of
##                 the measure. 
##  
## ******************************************************************* 
## * Among all indices:                                                
## * 4 proposed 2 as the best number of clusters 
## * 1 proposed 3 as the best number of clusters 
## * 4 proposed 4 as the best number of clusters 
## * 8 proposed 5 as the best number of clusters 
## * 2 proposed 7 as the best number of clusters 
## * 1 proposed 13 as the best number of clusters 
## * 1 proposed 18 as the best number of clusters 
## * 2 proposed 20 as the best number of clusters 
## 
##                    ***** Conclusion *****                            
##  
## * According to the majority rule, the best number of clusters is  5 
##  
##  
## *******************************************************************</code></pre>
<pre class="r"><code>fviz_nbclust(nb)</code></pre>
<pre><code>## Among all indices: 
## ===================
## * 2 proposed  0 as the best number of clusters
## * 1 proposed  1 as the best number of clusters
## * 4 proposed  2 as the best number of clusters
## * 1 proposed  3 as the best number of clusters
## * 4 proposed  4 as the best number of clusters
## * 8 proposed  5 as the best number of clusters
## * 2 proposed  7 as the best number of clusters
## * 1 proposed  13 as the best number of clusters
## * 1 proposed  18 as the best number of clusters
## * 2 proposed  20 as the best number of clusters
## 
## Conclusion
## =========================
## * According to the majority rule, the best number of clusters is  5 .</code></pre>
<p><img src="index_files/figure-html/unnamed-chunk-23-3.png" width="672" /></p>
<p>This approach shows K=5 which is same result as the previous elbow plot shown. Since the results are both K=5 for both approaches, we agree that optimum number of clusters is 5</p>
</div>
<div id="d.-k-means-cluster-analysis" class="section level2">
<h2>D. K-Means Cluster Analysis</h2>
<pre class="r"><code>##PART D.
  #K-means clustering
K=5
set.seed(123)
results &lt;- kmeans(X.scaled, centers=K, iter.max=1000, nstart=1000)

  #cluster means
as.matrix(round(results$centers,4))</code></pre>
<pre><code>##   Inv_1M_Bef cust_age cust_tenure tottrans
## 1    -0.1253   1.3835     -0.3541  -0.4666
## 2    -0.1149   0.0644      1.7917   0.0647
## 3    -0.2259  -0.3213     -0.1115   1.4227
## 4     4.0731   0.4696      0.1635  -0.1673
## 5    -0.1817  -0.6388     -0.4041  -0.4872</code></pre>
<pre class="r"><code>  #add cluster number to scaled data
map_to_xscale=as.data.frame(cbind(X.scaled,Old_Clust_Num=results$cluster))
map2=sqldf(&#39;select round(avg(Inv_1M_Bef),4),Old_Clust_Num 
           from map_to_xscale 
           group by Old_Clust_Num&#39;)
  #reorder
map3=map2[order(map2$`round(avg(Inv_1M_Bef),4)`),]
map3$New_Clust_Num=c(1:5)
  #change column names
colnames(map3)=c(&#39;Inv_1M_Bef&#39;,&#39;Old_Clust_Num&#39;,&#39;New_Clust_Num&#39;)
  #new cluster number table
map_completed=merge(map3,round(results$center,4),by=&#39;Inv_1M_Bef&#39;)
map_completed</code></pre>
<pre><code>##   Inv_1M_Bef Old_Clust_Num New_Clust_Num cust_age cust_tenure tottrans
## 1    -0.2259             3             1  -0.3213     -0.1115   1.4227
## 2    -0.1817             5             2  -0.6388     -0.4041  -0.4872
## 3    -0.1253             1             3   1.3835     -0.3541  -0.4666
## 4    -0.1149             2             4   0.0644      1.7917   0.0647
## 5     4.0731             4             5   0.4696      0.1635  -0.1673</code></pre>
<pre class="r"><code>  #add new cluster number to scaled data
map4=merge(map_to_xscale,map3[,c(&#39;Old_Clust_Num&#39;,&#39;New_Clust_Num&#39;)],by=&#39;Old_Clust_Num&#39;)

  #frequency table for customers in each clusters
table(map4$New_Clust_Num)</code></pre>
<pre><code>## 
##   1   2   3   4   5 
## 361 705 374 249  70</code></pre>
<pre class="r"><code>  #map to original data
map_to_orgdata=as.data.frame(cbind(data,Old_Clust_Num=results$cluster))

  #add new clust num column
map_to_orgdata2=merge(map_to_orgdata,map3[,c(&#39;Old_Clust_Num&#39;,&#39;New_Clust_Num&#39;)],by=&#39;Old_Clust_Num&#39;)

  #cluster means for each four variables
map_to_orgdata3=as.data.frame(map_to_orgdata2[,c(&#39;New_Clust_Num&#39;,&#39;Inv_1M_Bef&#39;,&#39;cust_age&#39;,&#39;cust_tenure&#39;,&#39;tottrans&#39;)])
cluster_means=aggregate(map_to_orgdata3, by = list(map_to_orgdata3$New_Clust_Num), FUN = mean)
cluster_means=round(cluster_means[c(2,3,4,5,6)],2)
cluster_means</code></pre>
<pre><code>##   New_Clust_Num Inv_1M_Bef cust_age cust_tenure tottrans
## 1             1    9926.31    33.31        2.07   109.52
## 2             2   11590.12    28.19        1.52    36.62
## 3             3   13713.62    60.78        1.61    37.41
## 4             4   14103.45    39.53        5.68    57.69
## 5             5  171632.90    46.05        2.59    48.83</code></pre>
<p>Here’s the table that shows our 5 clusters with their cluster means.</p>
</div>
<div id="e.-interpretation-of-the-segments" class="section level2">
<h2>E. Interpretation of the segments</h2>
<ul>
<li>Cluster 1: has the highest total transactions but it has the lowest Inv_1M_Bef</li>
<li>Cluster 2: has the youngest group of age, lowest customer tenure, and the lowest total transactions</li>
<li>Cluster 3: is the oldest group of age which is around 61 years old.</li>
<li>Cluster 4: has the highest customer tenure which means that they stay the longest with the company</li>
<li>Cluster 5: has the highest investments 1M_Before despite having a customer tenure only of 2.6 years</li>
</ul>
<p>Both Cluster 2 and 3 (the youngest and oldest age group respectively) have low cust_tenure (fall between 1.5-1.6) and low total transactions (35-37). We also noticed that having high total transactions doesn’t necessarily mean having a high investment. In fact, Cluster 1 who has the highest total transactions has the lowest Inv_1M_Bef.</p>
<p>What’s surprising is that the oldest group of age (Cluster 3) is not the one who make the biggest investment, but the Cluster 5, who are a little bit younger than Cluster 3, has the highest Inv_1M_Bef. And another thing that is surprising is that despite having an extremely high amount of Inv_1M_Bef in cluster 5, cluster 5 has a relatively low amount of total transactions of 48.83, while cluster 1 who has the lowest Inv_1M_Bef has 109.52 total transactions.</p>
<p>The cluster centers look quite vary, especially for Cluster 5. The cluster center for cluster 1- 4 are in the range of 9k-15k. While the cluster center for cluster 5 is around 170k. This could be due to potential outliers in cluster 5.</p>
</div>
<div id="f.-amount-of-money-lost-by-cluster" class="section level2">
<h2>F. Amount of money lost by cluster</h2>
<p>We calculated the average change in dollars (average of Inv_Chg) by clusters and by categ (good vs. bad services).</p>
<pre class="r"><code>##PART F. 
  #inv_change by clusters &amp; categ
inv_change_cluster=aggregate(map_to_orgdata2$Inv_Chg, by = list(map_to_orgdata2$New_Clust_Num,map_to_orgdata2$categ), FUN = mean)
inv_change_cluster=as.data.frame(inv_change_cluster)

  #create table for inv_change
inv_change_table=matrix(NA, nrow=5,ncol=3)
for (i in 1:5){
  inv_change_table[i,1]=i
  inv_change_table[i,2]=inv_change_cluster[i,3]
  inv_change_table[i,3]=inv_change_cluster[i+5,3]
}
inv_change_table =round(inv_change_table,2)  
  #change column names
colnames(inv_change_table)=c(&#39;New_Clust_Num&#39;,&#39;Avg_Inv_Chg_BAD&#39;,&#39;Avg_Inv_Chg_GOOD&#39;)
inv_change_table=as.data.frame(inv_change_table)
  
  #avg change (good-bad) of inv_change
inv_change_table=sqldf(&#39;select New_Clust_Num, Avg_Inv_Chg_BAD, Avg_Inv_Chg_GOOD,Avg_Inv_Chg_GOOD-Avg_Inv_Chg_BAD
                       from inv_change_table&#39;)
colnames(inv_change_table)=c(&#39;New_Clust_Num&#39;,&#39;Avg_Inv_Chg_BAD&#39;,&#39;Avg_Inv_Chg_GOOD&#39;,&#39;Avg_Chg_of_Inv_chg&#39;)
inv_change_table</code></pre>
<pre><code>##   New_Clust_Num Avg_Inv_Chg_BAD Avg_Inv_Chg_GOOD Avg_Chg_of_Inv_chg
## 1             1          894.54          1839.43             944.89
## 2             2          320.64          2203.88            1883.24
## 3             3          284.46          4836.08            4551.62
## 4             4          294.85           483.23             188.38
## 5             5       -25506.03        -37318.66          -11812.63</code></pre>
<p>According to the above table, cluster 2 and 3 have the highest change of investment between the bad and good service which indicates that cluster 2 and 3 will hurt the firm the most if they have bad services. Therefore, it’s important to take care of the customers in these two clusters to ensure they are satisfied with the service.</p>
<p>Interestingly, Cluster 5 has a negative number of Avg change of inv_change (-11,812.63). When the number is negative, it seems like the company will not lose money despite of their service.</p>
<p>Recalled from Part 2, Inv_Change is calculated by Investment 3 months after – Investment 1 month before. Since both number for Avg_Inv_Chg_Bad and Avg_Inv_Chg_Good are negative (-25,506.03 and -37,318.66), then in both scenarios, Inv_1M_Bef &gt; Inv_3M_Aft. Therefore, no matter how the ratings of the services are, customers are still pulling out money after the survey. And since the negative number of Avg_Inv_Chg_Good is more than the negative of Avg_Inv_Chg_Bad, the company will lose more money when the service is good. It’s possibly because of the following reasons:</p>
<ol style="list-style-type: decimal">
<li><p>This group of customers (Cluster 5) are short term investors (big amount of investment in a short amount of time) and they would not keep their money in the company for long. So no matter how the service is, they will still take the money out.</p></li>
<li><p>There are possible survey errors. They might have misconstrued the survey as 1= good and 5= bad. Or there’s possible proxy feedback by other people who entered survey on behalf of the customers.</p></li>
</ol>
</div>
<div id="g.-identifying-future-customers" class="section level2">
<h2>G. Identifying future customers</h2>
<div id="step-1-1" class="section level3">
<h3>step 1</h3>
<p>First, we need to standardize the new dataset to a mean of 0 and a standard deviation of 1.</p>
<pre class="r"><code>  ##Q1.standardize new data
new_scaled = as.data.frame(scale(new_data[,c(&#39;Inv_1M_Bef&#39;,&#39;cust_age&#39;,&#39;cust_tenure&#39;,&#39;tottrans&#39;)]))</code></pre>
</div>
<div id="step-2-1" class="section level3">
<h3>step 2</h3>
<p>Then, we calculated the Euclidean distance for our new customers to each clusters.</p>
<pre class="r"><code>  ##Q2. Euclidean distance 
  #cluster means from Part D.
map_completed=map_completed[c(1,4,5,6,2,3)]

  #Euclidean distance
distance_by_cluster = matrix(NA, nrow=nrow(new_scaled),ncol=5)
for (j in 1:nrow(map_completed)){
  for(i in 1:nrow(new_scaled)){
    distance=1
    distance[i] = sqrt((new_scaled[,1][i] - map_completed[j,1])^2 + (new_scaled[,2][i] - map_completed[j,2])^2 
                       + (new_scaled[,3][i] - map_completed[j,3])^2 +(new_scaled[,4][i] - map_completed[j,4])^2)
    distance_by_cluster[i,j]=distance[i]
  }
}
colnames(distance_by_cluster)=c(&#39;cluster1&#39;,&#39;cluster2&#39;,&#39;cluster3&#39;,&#39;cluster4&#39;,&#39;cluster5&#39;)
distance_by_cluster=as.data.frame(distance_by_cluster)</code></pre>
</div>
<div id="step-3-1" class="section level3">
<h3>step 3</h3>
<p>After we got the Euclidean distance, we can assign each customer to their closest cluster.</p>
<pre class="r"><code>  ##Q3.
  #assign customers to the nearest cluster center
distance_by_cluster$in_cluster&lt;-apply(X=distance_by_cluster, MARGIN=1, FUN=which.min)

  #frequency table for new customers
table(distance_by_cluster$in_cluster)</code></pre>
<pre><code>## 
##    1    2    3    4    5 
## 2603 4146 2734 2079  438</code></pre>
</div>
<div id="step-4-1" class="section level3">
<h3>step 4</h3>
<p>Now, we can find out how many new customers are in the top two clusters in terms of money lost from bad service. Recalled from Part F, we found out the cluster 2 and 3 are the ones that lose most money.</p>
<pre class="r"><code>  ##Q4.
  #map Cluster# back to data
completed_newdata=cbind(new_scaled,distance_by_cluster$in_cluster)
colnames(completed_newdata)=c(&#39;Inv_1M_Bef&#39;,&#39;cust_age&#39;,&#39;cust_tenure&#39;,&#39;tottrans&#39;,&#39;ClustNum&#39;)

  #customers in top two clusters that lose money
top_two=completed_newdata[completed_newdata$ClustNum==3 | completed_newdata$ClustNum==2,]

  #number of customers in top two clusters
length(top_two$ClustNum)</code></pre>
<pre><code>## [1] 6880</code></pre>
<pre class="r"><code>  #percentage of high risk customers 
round(length(top_two$ClustNum) / nrow(completed_newdata) *100,2)</code></pre>
<pre><code>## [1] 57.33</code></pre>
<p>For our new customers, there are 6,880 customers in total who are in cluster 2 or 3 which is 57.33% of all 12,000 new customers.</p>
</div>
<div id="step-5" class="section level3">
<h3>step 5</h3>
<p>Next, we can find out how much money is the firm expected to lose.</p>
<pre class="r"><code>  ##Q5.
  #expected average losses per customer by cluster in Part F
inv_change_table</code></pre>
<pre><code>##   New_Clust_Num Avg_Inv_Chg_BAD Avg_Inv_Chg_GOOD Avg_Chg_of_Inv_chg
## 1             1          894.54          1839.43             944.89
## 2             2          320.64          2203.88            1883.24
## 3             3          284.46          4836.08            4551.62
## 4             4          294.85           483.23             188.38
## 5             5       -25506.03        -37318.66          -11812.63</code></pre>
<pre class="r"><code>  #count customers in cluster 2 and 3
count_cluster3=sum(data.frame(top_two$ClustNum==3)*1)
count_cluster3</code></pre>
<pre><code>## [1] 2734</code></pre>
<pre class="r"><code>count_cluster2=length(top_two$ClustNum)-count_cluster3
count_cluster2</code></pre>
<pre><code>## [1] 4146</code></pre>
<pre class="r"><code>  #expected loss for cluster 3
inv_change_table[3,4]*count_cluster3</code></pre>
<pre><code>## [1] 12444129</code></pre>
<pre class="r"><code>  #expected loss for cluster 2
inv_change_table[2,4]*count_cluster2</code></pre>
<pre><code>## [1] 7807913</code></pre>
</div>
</div>
<div id="there-are-4146-customers-in-cluster-2-and-we-expected-them-to-lose-7807913.-we-had-2734-customer-in-cluster-3-which-is-expected-to-lose-12444129." class="section level2">
<h2>There are 4,146 customers in cluster 2 and we expected them to lose 7,807,913. We had 2,734 customer in cluster 3 which is expected to lose 12,444,129.</h2>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
